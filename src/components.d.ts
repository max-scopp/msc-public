/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { ButtonState, ButtonTheme } from "./components/msc-button/types";
import { StringBoolean } from "./core/definitions";
import { BaseInputType } from "./components/msc-input/types";
import { Direction } from "./components/msc-list/types";
import { SidebarPosition } from "./components/msc-sidebar/types";
import { ToastStateType } from "./components/msc-toast/types";
import { TooltipPosition } from "./components/msc-tooltip/types";
export namespace Components {
    interface MscBadge {
        "block": any;
        "color": string;
    }
    interface MscButton {
        /**
          * Wether or not the component is actually disabled.
         */
        "disabled": boolean;
        /**
          * Optional, if provided, the button contains an a11y-anchor inside.
         */
        "href": string;
        /**
          * What state the button has.
         */
        "state": ButtonState;
        /**
          * If "to" is provided, should the link have a target be set?
          * @see to
         */
        "target": '_blank' | '_self' | '_parent' | '_top' | string;
        /**
          * What kind of default-provided theme shall be applied.
         */
        "theme": ButtonTheme;
        /**
          * What kind of button this one is.
         */
        "type": 'submit' | 'reset' | string;
    }
    interface MscButtonGroup {
        /**
          * Hide's the last X items that don't fit to the parent container. items will be re-rendered as <msc-item />
         */
        "autohideItems": boolean;
    }
    interface MscCard {
        /**
          * Link where to go to when click
         */
        "href": string;
        /**
          * if an href (usually called "to" as attribute/prop) is provided, should there be a specific target type applied?
         */
        "target": string;
    }
    interface MscCollapsible {
        "hide": () => Promise<void>;
        "isVisible": boolean;
        "show": () => Promise<void>;
        "toggle": (newState?: boolean) => Promise<void>;
    }
    interface MscContent {
        /**
          * Overwrites the placement of content (NOT items!) on the horizontal axis See flexbox values May swap with horizontal alignment for correct behaviour
          * @see trackX
          * @see trackY
         */
        "alignX": string;
        /**
          * Overwrite placement of content (NOT items!) on the vertical axis See flexbox values May swap with horizontal alignment for correct behaviour
          * @see trackX
          * @see trackY
         */
        "alignY": string;
        /**
          * Centers the content of this container (NOT items!) on both axis.
         */
        "center": boolean;
        /**
          * Enables purposefully scrolling for the content of this tag.
         */
        "contentScroll": boolean;
        /**
          * Changes the placement direction of this container. See flexbox specs. Applies "weird behaviour" fixes of flexbox.
         */
        "trackX": boolean;
        /**
          * Changes the placement direction of this container. See flexbox specs. Applies "weird behaviour" fixes of flexbox.
         */
        "trackY": boolean;
    }
    interface MscDefine {
        "group": string;
        "name": string;
    }
    interface MscDisplayFilter {
        "for": string | HTMLElement;
    }
    interface MscFormField {
        "label": string;
    }
    interface MscGrid {
        /**
          * The minimum width of an item of the grid
         */
        "base": string | number;
        /**
          * Center container of all item-containers?
         */
        "centerContent": boolean;
        /**
          * Center grid items in their item-container?
         */
        "centerItems": boolean;
        /**
          * The minimum width of an item of the grid
         */
        "gap": string | number;
        /**
          * Should every cell's height equal to it's --base width?
         */
        "squared": boolean;
        /**
          * Define's the grid-template
         */
        "template": string;
    }
    interface MscIcon {
        /**
          * The iconName to resolve. This is dependant on how you declared your own IconSet.
         */
        "name": string;
        /**
          * The IconSet to pick the icon-name from. If not provied, the `defaultIconSet` is used from ApplicationService.
         */
        "set": string;
    }
    interface MscInput {
        /**
          * Should this input field autocomplete? Ignored for type="radio" and type="checkbox"
         */
        "autocomplete": boolean | StringBoolean;
        /**
          * Is your input disabled?
         */
        "disabled": boolean | StringBoolean;
        /**
          * Under what name should the value be stored inside the form?
         */
        "name": string;
        /**
          * The value to display when there is no value.
         */
        "placeholder": string;
        /**
          * Is your input required?
         */
        "required": boolean | StringBoolean;
        /**
          * The type of input you need.
         */
        "type": BaseInputType;
        /**
          * The value the component has/holds.
         */
        "value": any;
    }
    interface MscItem {
        "active": boolean;
        /**
          * An attribute/prop that is usually exposed as "to" which intern will open the provided link when activated. Or whatever the criteria is. !IMPORTANT! To make your life easier, be sure to set the prop to "reflect" the current value!
         */
        "href": string;
        "interactive": boolean;
        /**
          * if an href (usually called "to" as attribute/prop) is provided, should there be a specific target type applied?
         */
        "target": string;
    }
    interface MscList {
        "direction": Direction;
        "gap": number | string;
        "reverse": boolean;
    }
    interface MscLoader {
    }
    interface MscMenu {
        "open": boolean;
        "positionTo": string | HTMLElement;
    }
    interface MscModal {
        /**
          * Closes the modal, even if it's already closed.
         */
        "close": () => Promise<void>;
        /**
          * Show's an closing-X at the top right.
         */
        "closingX": boolean;
        /**
          * The important message you need to devliever to your user. If an array is supplied, each item will be wrapped in an paragraph.
         */
        "displayMessage": string | string[];
        /**
          * If provided, this value is used to render the default, negative button. Only needed to overwrite the text, you can also overwrite the whole button if you define "data-negative" as attribute inside your slot named action.
         */
        "displayNegativeText": string;
        /**
          * If provided, this value is used to render the default, positive button. Only needed to overwrite the text, you can also overwrite the whole button if you define "data-positive" as attribute inside your slot named action.
         */
        "displayPositiveText": string;
        /**
          * The title to display at the top. Supply a falsy value to disclose.
         */
        "displayTitle": string;
        /**
          * Don't position using "absolute". Ignore parent, use position "fixed" when true.
         */
        "global": boolean;
        /**
          * *** DO NOT SET THIS VALUE BY HAND; THIS IS READONLY/INITIAL ASSIGNMENT *** If you're using a framework, you can set it. Otherwise, no. Call myModal.toggle() in html. Designed for JSX assignment.
         */
        "isVisible": boolean;
        /**
          * Not only can you overwrite the texts and buttons that are present by default, using this prop you are also be able to exclude certain actions. E.g. Dialogs.alert() will omit the negative action.
         */
        "omittedActions": string | string[];
        "onaffirm": (...anyArgs: any[]) => any;
        "onreject": (...anyArgs: any[]) => any;
        /**
          * Opens the modal, even if it's already open.
         */
        "open": () => Promise<void>;
        /**
          * Defines the Modal-Role. Is it a dismissable alert or dialog?
         */
        "role": 'dialog' | 'alert' | 'alertdialog';
        /**
          * Invert's the current visibillity state. But you can also define a specific visibillity state as argument, but might wanna try `show()` or `close()` first.
          * @param newState The new forcefully defined state
         */
        "toggle": (newState?: boolean) => Promise<void>;
    }
    interface MscProgressIndicator {
        /**
          * Ongoing requests reported lazily by ApiService
         */
        "ongoing": (requests: Request[], aborted?: Error | Response) => Promise<void>;
    }
    interface MscRequestNotifier {
    }
    interface MscSidebar {
        /**
          * Should the Sidebar expand when you're near it?
         */
        "autoShow": boolean;
        /**
          * If true, styling applies position: fixed instead of position: absolute
         */
        "fixed": boolean;
        /**
          * Hides the Sidebar.
         */
        "hide": () => Promise<void>;
        /**
          * Should the Sidebar always be open?
         */
        "keepOpen": boolean;
        /**
          * Wether or not the sidebar should take up space in the document. If true, full content is exposed on hovering/tap.
         */
        "overlay": boolean;
        /**
          * Shows the Sidebar.
         */
        "show": () => Promise<void>;
        /**
          * If true, styling applies position: fixed instead of position: absolute
         */
        "side": SidebarPosition;
        /**
          * Controls wether or not only one item can be expanded.
         */
        "single": boolean;
        /**
          * Inverts current state or forces a specific state
          * @param newState
         */
        "toggle": (newState?: boolean) => Promise<void>;
    }
    interface MscTitle {
        "subline": boolean;
    }
    interface MscToast {
        /**
          * Removes the toast
         */
        "dismiss": () => Promise<void>;
        /**
          * If true, toast will be gone when clicked.
         */
        "dismissable": boolean;
        /**
          * If true, only the most important things are rendered to make the toast work. Pure extendabillity for your!
         */
        "indicator": boolean;
        /**
          * The message to show in the Toast.
         */
        "message": string;
        /**
          * A small string that's rendered <**bold** />
         */
        "messageTitle": string;
        /**
          * Visual state how the tosat looks
         */
        "state": ToastStateType;
        /**
          * How long the toast shall be visible. Use a falsy value for no timeout.
         */
        "timeout": number | false;
    }
    interface MscToastContainer {
        /**
          * Adds an existing toast node
         */
        "addToast": (toast: HTMLMscToastElement) => Promise<void>;
        /**
          * Removes an existing toast node.
         */
        "removeToast": (toast: HTMLMscToastElement) => Promise<void>;
    }
    interface MscTooltip {
        /**
          * Idenficator (id) for targeted element. Fallback to <slot/> if not provided. Tooltip will be placed relative to the found element. If the element is not found, the component will break (but a developer notice will be logged).
         */
        "for": string;
        /**
          * All tooltips are now globally positioned by default. It's just better.
          * @deprecated
         */
        "global": boolean;
        /**
          * What should the displayed within the tooltip?
         */
        "label": string;
        /**
          * Where the actual tooltip needs to be positioned. Ignored when there is no space.
         */
        "position": TooltipPosition;
    }
}
declare global {
    interface HTMLMscBadgeElement extends Components.MscBadge, HTMLStencilElement {
    }
    var HTMLMscBadgeElement: {
        prototype: HTMLMscBadgeElement;
        new (): HTMLMscBadgeElement;
    };
    interface HTMLMscButtonElement extends Components.MscButton, HTMLStencilElement {
    }
    var HTMLMscButtonElement: {
        prototype: HTMLMscButtonElement;
        new (): HTMLMscButtonElement;
    };
    interface HTMLMscButtonGroupElement extends Components.MscButtonGroup, HTMLStencilElement {
    }
    var HTMLMscButtonGroupElement: {
        prototype: HTMLMscButtonGroupElement;
        new (): HTMLMscButtonGroupElement;
    };
    interface HTMLMscCardElement extends Components.MscCard, HTMLStencilElement {
    }
    var HTMLMscCardElement: {
        prototype: HTMLMscCardElement;
        new (): HTMLMscCardElement;
    };
    interface HTMLMscCollapsibleElement extends Components.MscCollapsible, HTMLStencilElement {
    }
    var HTMLMscCollapsibleElement: {
        prototype: HTMLMscCollapsibleElement;
        new (): HTMLMscCollapsibleElement;
    };
    interface HTMLMscContentElement extends Components.MscContent, HTMLStencilElement {
    }
    var HTMLMscContentElement: {
        prototype: HTMLMscContentElement;
        new (): HTMLMscContentElement;
    };
    interface HTMLMscDefineElement extends Components.MscDefine, HTMLStencilElement {
    }
    var HTMLMscDefineElement: {
        prototype: HTMLMscDefineElement;
        new (): HTMLMscDefineElement;
    };
    interface HTMLMscDisplayFilterElement extends Components.MscDisplayFilter, HTMLStencilElement {
    }
    var HTMLMscDisplayFilterElement: {
        prototype: HTMLMscDisplayFilterElement;
        new (): HTMLMscDisplayFilterElement;
    };
    interface HTMLMscFormFieldElement extends Components.MscFormField, HTMLStencilElement {
    }
    var HTMLMscFormFieldElement: {
        prototype: HTMLMscFormFieldElement;
        new (): HTMLMscFormFieldElement;
    };
    interface HTMLMscGridElement extends Components.MscGrid, HTMLStencilElement {
    }
    var HTMLMscGridElement: {
        prototype: HTMLMscGridElement;
        new (): HTMLMscGridElement;
    };
    interface HTMLMscIconElement extends Components.MscIcon, HTMLStencilElement {
    }
    var HTMLMscIconElement: {
        prototype: HTMLMscIconElement;
        new (): HTMLMscIconElement;
    };
    interface HTMLMscInputElement extends Components.MscInput, HTMLStencilElement {
    }
    var HTMLMscInputElement: {
        prototype: HTMLMscInputElement;
        new (): HTMLMscInputElement;
    };
    interface HTMLMscItemElement extends Components.MscItem, HTMLStencilElement {
    }
    var HTMLMscItemElement: {
        prototype: HTMLMscItemElement;
        new (): HTMLMscItemElement;
    };
    interface HTMLMscListElement extends Components.MscList, HTMLStencilElement {
    }
    var HTMLMscListElement: {
        prototype: HTMLMscListElement;
        new (): HTMLMscListElement;
    };
    interface HTMLMscLoaderElement extends Components.MscLoader, HTMLStencilElement {
    }
    var HTMLMscLoaderElement: {
        prototype: HTMLMscLoaderElement;
        new (): HTMLMscLoaderElement;
    };
    interface HTMLMscMenuElement extends Components.MscMenu, HTMLStencilElement {
    }
    var HTMLMscMenuElement: {
        prototype: HTMLMscMenuElement;
        new (): HTMLMscMenuElement;
    };
    interface HTMLMscModalElement extends Components.MscModal, HTMLStencilElement {
    }
    var HTMLMscModalElement: {
        prototype: HTMLMscModalElement;
        new (): HTMLMscModalElement;
    };
    interface HTMLMscProgressIndicatorElement extends Components.MscProgressIndicator, HTMLStencilElement {
    }
    var HTMLMscProgressIndicatorElement: {
        prototype: HTMLMscProgressIndicatorElement;
        new (): HTMLMscProgressIndicatorElement;
    };
    interface HTMLMscRequestNotifierElement extends Components.MscRequestNotifier, HTMLStencilElement {
    }
    var HTMLMscRequestNotifierElement: {
        prototype: HTMLMscRequestNotifierElement;
        new (): HTMLMscRequestNotifierElement;
    };
    interface HTMLMscSidebarElement extends Components.MscSidebar, HTMLStencilElement {
    }
    var HTMLMscSidebarElement: {
        prototype: HTMLMscSidebarElement;
        new (): HTMLMscSidebarElement;
    };
    interface HTMLMscTitleElement extends Components.MscTitle, HTMLStencilElement {
    }
    var HTMLMscTitleElement: {
        prototype: HTMLMscTitleElement;
        new (): HTMLMscTitleElement;
    };
    interface HTMLMscToastElement extends Components.MscToast, HTMLStencilElement {
    }
    var HTMLMscToastElement: {
        prototype: HTMLMscToastElement;
        new (): HTMLMscToastElement;
    };
    interface HTMLMscToastContainerElement extends Components.MscToastContainer, HTMLStencilElement {
    }
    var HTMLMscToastContainerElement: {
        prototype: HTMLMscToastContainerElement;
        new (): HTMLMscToastContainerElement;
    };
    interface HTMLMscTooltipElement extends Components.MscTooltip, HTMLStencilElement {
    }
    var HTMLMscTooltipElement: {
        prototype: HTMLMscTooltipElement;
        new (): HTMLMscTooltipElement;
    };
    interface HTMLElementTagNameMap {
        "msc-badge": HTMLMscBadgeElement;
        "msc-button": HTMLMscButtonElement;
        "msc-button-group": HTMLMscButtonGroupElement;
        "msc-card": HTMLMscCardElement;
        "msc-collapsible": HTMLMscCollapsibleElement;
        "msc-content": HTMLMscContentElement;
        "msc-define": HTMLMscDefineElement;
        "msc-display-filter": HTMLMscDisplayFilterElement;
        "msc-form-field": HTMLMscFormFieldElement;
        "msc-grid": HTMLMscGridElement;
        "msc-icon": HTMLMscIconElement;
        "msc-input": HTMLMscInputElement;
        "msc-item": HTMLMscItemElement;
        "msc-list": HTMLMscListElement;
        "msc-loader": HTMLMscLoaderElement;
        "msc-menu": HTMLMscMenuElement;
        "msc-modal": HTMLMscModalElement;
        "msc-progress-indicator": HTMLMscProgressIndicatorElement;
        "msc-request-notifier": HTMLMscRequestNotifierElement;
        "msc-sidebar": HTMLMscSidebarElement;
        "msc-title": HTMLMscTitleElement;
        "msc-toast": HTMLMscToastElement;
        "msc-toast-container": HTMLMscToastContainerElement;
        "msc-tooltip": HTMLMscTooltipElement;
    }
}
declare namespace LocalJSX {
    interface MscBadge {
        "block"?: any;
        "color"?: string;
    }
    interface MscButton {
        /**
          * Wether or not the component is actually disabled.
         */
        "disabled"?: boolean;
        /**
          * Optional, if provided, the button contains an a11y-anchor inside.
         */
        "href"?: string;
        /**
          * What state the button has.
         */
        "state"?: ButtonState;
        /**
          * If "to" is provided, should the link have a target be set?
          * @see to
         */
        "target"?: '_blank' | '_self' | '_parent' | '_top' | string;
        /**
          * What kind of default-provided theme shall be applied.
         */
        "theme"?: ButtonTheme;
        /**
          * What kind of button this one is.
         */
        "type"?: 'submit' | 'reset' | string;
    }
    interface MscButtonGroup {
        /**
          * Hide's the last X items that don't fit to the parent container. items will be re-rendered as <msc-item />
         */
        "autohideItems"?: boolean;
    }
    interface MscCard {
        /**
          * Link where to go to when click
         */
        "href"?: string;
        /**
          * if an href (usually called "to" as attribute/prop) is provided, should there be a specific target type applied?
         */
        "target"?: string;
    }
    interface MscCollapsible {
        "isVisible"?: boolean;
    }
    interface MscContent {
        /**
          * Overwrites the placement of content (NOT items!) on the horizontal axis See flexbox values May swap with horizontal alignment for correct behaviour
          * @see trackX
          * @see trackY
         */
        "alignX"?: string;
        /**
          * Overwrite placement of content (NOT items!) on the vertical axis See flexbox values May swap with horizontal alignment for correct behaviour
          * @see trackX
          * @see trackY
         */
        "alignY"?: string;
        /**
          * Centers the content of this container (NOT items!) on both axis.
         */
        "center"?: boolean;
        /**
          * Enables purposefully scrolling for the content of this tag.
         */
        "contentScroll"?: boolean;
        /**
          * Changes the placement direction of this container. See flexbox specs. Applies "weird behaviour" fixes of flexbox.
         */
        "trackX"?: boolean;
        /**
          * Changes the placement direction of this container. See flexbox specs. Applies "weird behaviour" fixes of flexbox.
         */
        "trackY"?: boolean;
    }
    interface MscDefine {
        "group"?: string;
        "name"?: string;
    }
    interface MscDisplayFilter {
        "for"?: string | HTMLElement;
    }
    interface MscFormField {
        "label"?: string;
    }
    interface MscGrid {
        /**
          * The minimum width of an item of the grid
         */
        "base"?: string | number;
        /**
          * Center container of all item-containers?
         */
        "centerContent"?: boolean;
        /**
          * Center grid items in their item-container?
         */
        "centerItems"?: boolean;
        /**
          * The minimum width of an item of the grid
         */
        "gap"?: string | number;
        /**
          * Should every cell's height equal to it's --base width?
         */
        "squared"?: boolean;
        /**
          * Define's the grid-template
         */
        "template"?: string;
    }
    interface MscIcon {
        /**
          * The iconName to resolve. This is dependant on how you declared your own IconSet.
         */
        "name"?: string;
        /**
          * The IconSet to pick the icon-name from. If not provied, the `defaultIconSet` is used from ApplicationService.
         */
        "set"?: string;
    }
    interface MscInput {
        /**
          * Should this input field autocomplete? Ignored for type="radio" and type="checkbox"
         */
        "autocomplete"?: boolean | StringBoolean;
        /**
          * Is your input disabled?
         */
        "disabled"?: boolean | StringBoolean;
        /**
          * Under what name should the value be stored inside the form?
         */
        "name"?: string;
        /**
          * CustomEvent that dispatches when the content changes.
         */
        "onUserInput"?: (event: CustomEvent<any>) => void;
        /**
          * The value to display when there is no value.
         */
        "placeholder"?: string;
        /**
          * Is your input required?
         */
        "required"?: boolean | StringBoolean;
        /**
          * The type of input you need.
         */
        "type"?: BaseInputType;
        /**
          * The value the component has/holds.
         */
        "value"?: any;
    }
    interface MscItem {
        "active"?: boolean;
        /**
          * An attribute/prop that is usually exposed as "to" which intern will open the provided link when activated. Or whatever the criteria is. !IMPORTANT! To make your life easier, be sure to set the prop to "reflect" the current value!
         */
        "href"?: string;
        "interactive"?: boolean;
        /**
          * if an href (usually called "to" as attribute/prop) is provided, should there be a specific target type applied?
         */
        "target"?: string;
    }
    interface MscList {
        "direction"?: Direction;
        "gap"?: number | string;
        "reverse"?: boolean;
    }
    interface MscLoader {
    }
    interface MscMenu {
        "onClose"?: (event: CustomEvent<any>) => void;
        "open"?: boolean;
        "positionTo"?: string | HTMLElement;
    }
    interface MscModal {
        /**
          * Show's an closing-X at the top right.
         */
        "closingX"?: boolean;
        /**
          * The important message you need to devliever to your user. If an array is supplied, each item will be wrapped in an paragraph.
         */
        "displayMessage"?: string | string[];
        /**
          * If provided, this value is used to render the default, negative button. Only needed to overwrite the text, you can also overwrite the whole button if you define "data-negative" as attribute inside your slot named action.
         */
        "displayNegativeText"?: string;
        /**
          * If provided, this value is used to render the default, positive button. Only needed to overwrite the text, you can also overwrite the whole button if you define "data-positive" as attribute inside your slot named action.
         */
        "displayPositiveText"?: string;
        /**
          * The title to display at the top. Supply a falsy value to disclose.
         */
        "displayTitle"?: string;
        /**
          * Don't position using "absolute". Ignore parent, use position "fixed" when true.
         */
        "global"?: boolean;
        /**
          * *** DO NOT SET THIS VALUE BY HAND; THIS IS READONLY/INITIAL ASSIGNMENT *** If you're using a framework, you can set it. Otherwise, no. Call myModal.toggle() in html. Designed for JSX assignment.
         */
        "isVisible"?: boolean;
        /**
          * Not only can you overwrite the texts and buttons that are present by default, using this prop you are also be able to exclude certain actions. E.g. Dialogs.alert() will omit the negative action.
         */
        "omittedActions"?: string | string[];
        /**
          * Event and static prop to define what happens when the user wants to proceed. This may be the "apply", or "ok" button, it's usually also theme="primary" You can listen on this actions usinmg "affirm".
         */
        "onAffirm"?: (event: CustomEvent<any>) => void;
        /**
          * Custom event that gets triggered whenever this instance changes it's `isVisible` property. Access the value using `detail`. Access the modal using `target`.
         */
        "onModal-toggled"?: (event: CustomEvent<any>) => void;
        /**
          * Event and static prop to define what happens when the user does NOT want to proceed. This may be the "cancel", or "reset" button, it's usually is rendered with default styles. You can listen on this actions usinmg "reject".
         */
        "onReject"?: (event: CustomEvent<any>) => void;
        "onaffirm"?: (...anyArgs: any[]) => any;
        "onreject"?: (...anyArgs: any[]) => any;
        /**
          * Defines the Modal-Role. Is it a dismissable alert or dialog?
         */
        "role"?: 'dialog' | 'alert' | 'alertdialog';
    }
    interface MscProgressIndicator {
    }
    interface MscRequestNotifier {
    }
    interface MscSidebar {
        /**
          * Should the Sidebar expand when you're near it?
         */
        "autoShow"?: boolean;
        /**
          * If true, styling applies position: fixed instead of position: absolute
         */
        "fixed"?: boolean;
        /**
          * Should the Sidebar always be open?
         */
        "keepOpen"?: boolean;
        /**
          * Wether or not the sidebar should take up space in the document. If true, full content is exposed on hovering/tap.
         */
        "overlay"?: boolean;
        /**
          * If true, styling applies position: fixed instead of position: absolute
         */
        "side"?: SidebarPosition;
        /**
          * Controls wether or not only one item can be expanded.
         */
        "single"?: boolean;
    }
    interface MscTitle {
        "subline"?: boolean;
    }
    interface MscToast {
        /**
          * If true, toast will be gone when clicked.
         */
        "dismissable"?: boolean;
        /**
          * If true, only the most important things are rendered to make the toast work. Pure extendabillity for your!
         */
        "indicator"?: boolean;
        /**
          * The message to show in the Toast.
         */
        "message"?: string;
        /**
          * A small string that's rendered <**bold** />
         */
        "messageTitle"?: string;
        /**
          * CLose event when dismissed
         */
        "onClose"?: (event: CustomEvent<any>) => void;
        /**
          * Visual state how the tosat looks
         */
        "state"?: ToastStateType;
        /**
          * How long the toast shall be visible. Use a falsy value for no timeout.
         */
        "timeout"?: number | false;
    }
    interface MscToastContainer {
    }
    interface MscTooltip {
        /**
          * Idenficator (id) for targeted element. Fallback to <slot/> if not provided. Tooltip will be placed relative to the found element. If the element is not found, the component will break (but a developer notice will be logged).
         */
        "for"?: string;
        /**
          * All tooltips are now globally positioned by default. It's just better.
          * @deprecated
         */
        "global"?: boolean;
        /**
          * What should the displayed within the tooltip?
         */
        "label"?: string;
        /**
          * Where the actual tooltip needs to be positioned. Ignored when there is no space.
         */
        "position"?: TooltipPosition;
    }
    interface IntrinsicElements {
        "msc-badge": MscBadge;
        "msc-button": MscButton;
        "msc-button-group": MscButtonGroup;
        "msc-card": MscCard;
        "msc-collapsible": MscCollapsible;
        "msc-content": MscContent;
        "msc-define": MscDefine;
        "msc-display-filter": MscDisplayFilter;
        "msc-form-field": MscFormField;
        "msc-grid": MscGrid;
        "msc-icon": MscIcon;
        "msc-input": MscInput;
        "msc-item": MscItem;
        "msc-list": MscList;
        "msc-loader": MscLoader;
        "msc-menu": MscMenu;
        "msc-modal": MscModal;
        "msc-progress-indicator": MscProgressIndicator;
        "msc-request-notifier": MscRequestNotifier;
        "msc-sidebar": MscSidebar;
        "msc-title": MscTitle;
        "msc-toast": MscToast;
        "msc-toast-container": MscToastContainer;
        "msc-tooltip": MscTooltip;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "msc-badge": LocalJSX.MscBadge & JSXBase.HTMLAttributes<HTMLMscBadgeElement>;
            "msc-button": LocalJSX.MscButton & JSXBase.HTMLAttributes<HTMLMscButtonElement>;
            "msc-button-group": LocalJSX.MscButtonGroup & JSXBase.HTMLAttributes<HTMLMscButtonGroupElement>;
            "msc-card": LocalJSX.MscCard & JSXBase.HTMLAttributes<HTMLMscCardElement>;
            "msc-collapsible": LocalJSX.MscCollapsible & JSXBase.HTMLAttributes<HTMLMscCollapsibleElement>;
            "msc-content": LocalJSX.MscContent & JSXBase.HTMLAttributes<HTMLMscContentElement>;
            "msc-define": LocalJSX.MscDefine & JSXBase.HTMLAttributes<HTMLMscDefineElement>;
            "msc-display-filter": LocalJSX.MscDisplayFilter & JSXBase.HTMLAttributes<HTMLMscDisplayFilterElement>;
            "msc-form-field": LocalJSX.MscFormField & JSXBase.HTMLAttributes<HTMLMscFormFieldElement>;
            "msc-grid": LocalJSX.MscGrid & JSXBase.HTMLAttributes<HTMLMscGridElement>;
            "msc-icon": LocalJSX.MscIcon & JSXBase.HTMLAttributes<HTMLMscIconElement>;
            "msc-input": LocalJSX.MscInput & JSXBase.HTMLAttributes<HTMLMscInputElement>;
            "msc-item": LocalJSX.MscItem & JSXBase.HTMLAttributes<HTMLMscItemElement>;
            "msc-list": LocalJSX.MscList & JSXBase.HTMLAttributes<HTMLMscListElement>;
            "msc-loader": LocalJSX.MscLoader & JSXBase.HTMLAttributes<HTMLMscLoaderElement>;
            "msc-menu": LocalJSX.MscMenu & JSXBase.HTMLAttributes<HTMLMscMenuElement>;
            "msc-modal": LocalJSX.MscModal & JSXBase.HTMLAttributes<HTMLMscModalElement>;
            "msc-progress-indicator": LocalJSX.MscProgressIndicator & JSXBase.HTMLAttributes<HTMLMscProgressIndicatorElement>;
            "msc-request-notifier": LocalJSX.MscRequestNotifier & JSXBase.HTMLAttributes<HTMLMscRequestNotifierElement>;
            "msc-sidebar": LocalJSX.MscSidebar & JSXBase.HTMLAttributes<HTMLMscSidebarElement>;
            "msc-title": LocalJSX.MscTitle & JSXBase.HTMLAttributes<HTMLMscTitleElement>;
            "msc-toast": LocalJSX.MscToast & JSXBase.HTMLAttributes<HTMLMscToastElement>;
            "msc-toast-container": LocalJSX.MscToastContainer & JSXBase.HTMLAttributes<HTMLMscToastContainerElement>;
            "msc-tooltip": LocalJSX.MscTooltip & JSXBase.HTMLAttributes<HTMLMscTooltipElement>;
        }
    }
}
